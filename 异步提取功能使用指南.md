# 异步文本提取功能使用指南

## 概述

本系统已升级支持异步文本提取功能，可以立即返回成功响应，而实际的提取任务在后台异步执行。这样可以显著提升用户体验，特别适合处理耗时较长的文本提取任务。

## 核心特性

### ✅ 立即响应
- 请求提交后立即返回 `{"success": true}` 响应
- 不需要等待提取任务完成
- 响应时间通常在 50ms 以内

### ✅ 后台处理
- 提取任务在专用线程池中异步执行
- 支持并发处理多个提取任务
- 自动保存提取结果到数据库

### ✅ 任务监控
- 实时监控任务执行状态
- 统计成功率、失败率、平均执行时间
- 提供详细的性能分析数据

### ✅ 高性能配置
- 核心线程数：5
- 最大线程数：20
- 队列容量：100
- 支持高并发场景

## API接口

### 1. 异步单文本提取

**接口地址：** `POST /api/v1/async/extract`

**请求示例：**
```json
{
    "textInput": "刘德华是香港著名演员和歌手，出演过《无间道》等经典电影。",
    "extractParams": "triples"
}
```

**响应示例：**
```json
{
    "success": true,
    "message": "任务已提交，正在后台处理",
    "timestamp": 1703123456789
}
```

### 2. 异步数组格式提取

**接口地址：** `POST /api/v1/async/extract`

**请求示例：**
```json
{
    "textInput": [
        "张艺谋执导的《英雄》是一部古装武侠电影。",
        "《三体》三部曲是刘慈欣的代表作品。"
    ],
    "extractParams": "relations"
}
```

### 3. 异步批量提取

**接口地址：** `POST /api/v1/async/batch`

**请求示例：**
```json
{
    "textInputs": [
        "周杰伦是台湾流行音乐歌手，创作了《青花瓷》等热门歌曲。",
        "《流浪地球》是刘慈欣科幻小说改编的电影，由郭帆导演。",
        "马云创办了阿里巴巴集团，推动了中国电子商务的发展。"
    ],
    "extractParams": "entities"
}
```

### 4. 任务监控统计

**接口地址：** `GET /api/v1/async/monitor`

**响应示例：**
```json
{
    "total_tasks": 25,
    "completed_tasks": 23,
    "failed_tasks": 1,
    "running_tasks": 1,
    "success_rate": "92.00%",
    "failure_rate": "4.00%",
    "average_execution_time": "2456.78ms",
    "total_execution_time": "56505ms",
    "status": "processing",
    "timestamp": 1703123456789
}
```

### 5. 重置监控统计

**接口地址：** `POST /api/v1/async/monitor/reset`

### 6. 异步服务信息

**接口地址：** `GET /api/v1/async/info`

## 技术架构

### 异步处理流程

```
1. 客户端提交请求 → AsyncExtractController
2. 立即返回成功响应 ← {"success": true}
3. 启动异步任务 → TextExtractionService.startAsyncExtraction()
4. 后台执行提取 → SmartAIProvider.process()
5. 保存到数据库 → DatabaseService.saveSocialData()
6. 更新监控统计 → AsyncTaskMonitor
```

### 线程池配置

```java
@Bean("textExtractionExecutor")
public Executor textExtractionExecutor() {
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
    executor.setCorePoolSize(5);        // 核心线程数
    executor.setMaxPoolSize(20);        // 最大线程数
    executor.setQueueCapacity(100);     // 队列容量
    executor.setThreadNamePrefix("TextExtract-");
    executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
    return executor;
}
```

### 监控组件

- **AsyncTaskMonitor**: 任务监控服务
- **原子计数器**: 线程安全的统计计数
- **ConcurrentHashMap**: 并发安全的任务时间记录
- **任务ID**: 唯一标识每个异步任务

## 使用场景

### 适合异步处理的场景

1. **大批量文本提取**
   - 批量处理多个文档
   - 长文本内容提取
   - 复杂关系分析

2. **高并发场景**
   - 多用户同时提交
   - API调用频繁
   - 系统负载较高

3. **用户体验优化**
   - 需要快速响应
   - 避免页面等待
   - 提升交互性能

### 继续使用同步接口的场景

1. **小文本快速提取**
   - 文本长度较短
   - 处理时间很快
   - 需要立即获取结果

2. **调试和测试**
   - 开发阶段调试
   - 验证提取结果
   - 性能测试对比

## 性能对比

### 响应时间对比

| 处理模式 | 平均响应时间 | 适用场景 | 优势 |
|---------|-------------|----------|------|
| 异步处理 | 50-100ms | 大批量、高并发 | 立即响应、高吞吐量 |
| 同步处理 | 2000-5000ms | 小文本、调试 | 立即获取结果、简单直接 |

### 并发能力对比

- **异步模式**: 支持100+并发请求
- **同步模式**: 受限于处理时间，并发能力较低

## 最佳实践

### 1. 选择合适的接口

```python
# 单个短文本 - 使用同步接口
POST /api/v1/extract

# 单个长文本 - 使用异步接口
POST /api/v1/async/extract

# 批量处理 - 使用异步批量接口
POST /api/v1/async/batch
```

### 2. 监控任务状态

```python
import requests
import time

# 提交异步任务
response = requests.post('/api/v1/async/extract', json=data)
if response.json().get('success'):
    print("任务已提交")

# 监控任务进度
while True:
    stats = requests.get('/api/v1/async/monitor').json()
    print(f"运行中任务: {stats['running_tasks']}")
    if stats['running_tasks'] == 0:
        break
    time.sleep(1)
```

### 3. 错误处理

```python
try:
    response = requests.post('/api/v1/async/extract', json=data, timeout=10)
    result = response.json()
    if result.get('success'):
        print("异步任务提交成功")
    else:
        print(f"任务提交失败: {result.get('error')}")
except requests.exceptions.Timeout:
    print("请求超时")
except Exception as e:
    print(f"请求异常: {str(e)}")
```

## 测试脚本

### 快速测试

```bash
# 运行异步API测试
python test_async_api.py
```

### 压力测试

```python
import concurrent.futures
import requests

def submit_async_task(text):
    return requests.post('/api/v1/async/extract', 
                        json={'textInput': text})

# 并发提交100个任务
texts = ["测试文本" + str(i) for i in range(100)]
with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
    futures = [executor.submit(submit_async_task, text) for text in texts]
    results = [f.result() for f in concurrent.futures.as_completed(futures)]
```

## 常见问题

### Q: 如何知道异步任务是否完成？
A: 可以通过监控接口 `/api/v1/async/monitor` 查看 `running_tasks` 字段，为0表示所有任务完成。

### Q: 异步任务失败了怎么办？
A: 失败的任务会记录在监控统计中，可以查看 `failed_tasks` 和日志了解具体原因。

### Q: 线程池满了会怎样？
A: 采用 `CallerRunsPolicy` 拒绝策略，会在调用线程中执行任务，保证不丢失。

### Q: 异步和同步接口可以混用吗？
A: 可以，两套接口相互独立，可以根据实际需求灵活选择。

## 监控和运维

### 监控指标

1. **任务统计**
   - 总任务数
   - 完成任务数
   - 失败任务数
   - 运行中任务数

2. **性能指标**
   - 成功率
   - 失败率
   - 平均执行时间
   - 总执行时间

3. **系统状态**
   - processing: 有任务在处理
   - idle: 空闲状态

### 日志示例

```
2023-12-21 10:30:15.123 INFO  异步任务开始 - 任务ID: task_1703123456789_a1b2, 输入长度: 45, 参数: triples
2023-12-21 10:30:17.456 INFO  异步任务完成 - 任务ID: task_1703123456789_a1b2, 执行时间: 2333ms
```

### 性能调优

1. **调整线程池大小**
   - 根据服务器CPU核数调整
   - 监控线程池使用率
   - 避免过度创建线程

2. **队列容量优化**
   - 根据内存情况调整
   - 避免内存溢出
   - 平衡响应速度和资源使用

## 总结

异步文本提取功能通过以下技术实现：

- **Spring Boot @Async**: 异步方法执行
- **ThreadPoolTaskExecutor**: 专用线程池
- **CompletableFuture**: 异步编程模型
- **AtomicLong/ConcurrentHashMap**: 线程安全统计
- **立即响应**: 只返回success状态，不返回提取内容

这样的设计既保证了用户体验（快速响应），又确保了系统性能（后台处理），是处理耗时任务的最佳实践方案。 