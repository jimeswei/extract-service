# 智能文本提取服务 - 系统架构设计文档

## 1. 架构概览

### 1.1 设计原则
- **简洁至上**: 最小化组件，最大化效率
- **数据驱动**: 基于现有数据库结构设计
- **协议兼容**: 保持MCP协议不变
- **直接入库**: 提取结果直接存储到MySQL

### 1.2 整体架构
```
┌─────────────┐   ┌─────────────────┐   ┌─────────────┐   ┌─────────────┐
│   MCP客户端  │──▶│  Extract Service │──▶│    Redis    │──▶│   MySQL     │
│             │   │                 │   │    Cache    │   │   Database  │
│ 智能体工具   │   │ 文本提取+入库    │   │ 192.168.3.78│   │192.168.3.78 │
└─────────────┘   └─────────────────┘   └─────────────┘   └─────────────┘
```

## 2. 核心组件设计

### 2.1 MCP服务层
**保持原有MCP协议不变**，提供标准化工具接口：

```java
@Service
public class TextExtractionService {
    
    @Tool(name = "extract_social_info")
    public String extractSocialInfo(String text, String extractTypes, boolean maskSensitive) {
        // 1. 文本预处理
        String cleanText = preprocess(text);
        
        // 2. AI智能提取
        ExtractionResult result = aiProvider.extract(cleanText);
        
        // 3. 数据入库
        persistToDatabase(result);
        
        // 4. 返回格式化结果
        return formatResponse(result);
    }
}
```

### 2.2 数据处理引擎
**三步走策略**：提取 → 映射 → 入库

```java
@Component
public class DataProcessor {
    
    public void persistToDatabase(ExtractionResult result) {
        // 批量处理，提升性能
        List<Celebrity> celebrities = mapToPersons(result.getPersons());
        List<Work> works = mapToWorks(result.getWorks());
        List<Event> events = mapToEvents(result.getEvents());
        
        // 事务性批量入库
        databaseService.batchSave(celebrities, works, events);
        
        // 保存关系数据
        saveRelations(result.getRelations());
    }
}
```

### 2.3 缓存策略
**Redis缓存优化性能**：

```java
@Service
public class CacheService {
    
    // 缓存提取结果，避免重复计算
    @Cacheable(value = "extraction", key = "#text.hashCode()")
    public ExtractionResult getExtractionResult(String text) {
        return aiProvider.extract(text);
    }
    
    // 缓存数据库查询结果
    @Cacheable(value = "entities", key = "#entityId")
    public Celebrity getCelebrity(String entityId) {
        return celebrityRepository.findByCelebrityId(entityId);
    }
}
```

## 3. 数据流设计

### 3.1 处理流程
```
MCP请求 → 文本预处理 → AI提取 → 数据映射 → 批量入库 → 缓存更新 → 返回结果
```

### 3.2 数据映射规则
**直接映射到数据库表结构**：

| 提取实体 | 数据库表 | 映射字段 |
|---------|---------|---------|
| Person | celebrity | name, nationality, birthdate, gender, profession |
| Work | work | title, work_type, release_date, role, platform |
| Event | event | event_name, event_type, time |
| Relation | celebrity_celebrity | from, to, e_type |

## 4. 技术栈

### 4.1 核心框架
- **Spring Boot 3.x**: 应用框架
- **Spring Data JPA**: 数据访问
- **Spring Cache**: 缓存管理
- **Jackson**: JSON处理

### 4.2 基础设施
- **MySQL 8.0**: 主数据库 (localhost:3306)
- **Redis**: 缓存服务 (localhost:6379)
- **AI Provider**: 智能提取服务

## 5. 配置文件

### 5.1 application.yml
```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/extract-graph
    username: root
    password: 123456
    driver-class-name: com.mysql.cj.jdbc.Driver
    
  data:
    redis:
      host: localhost
      port: 6379
      timeout: 2000ms
      
  jpa:
    hibernate:
      ddl-auto: none
    show-sql: false
    
  cache:
    type: redis
    redis:
      time-to-live: 3600s

server:
  port: 2701

ai:
  mcp:
    server:
      name: intelligent-extraction-service-prod
      type: ASYNC
      version: 1.0.0
      enabled: true
      sse-endpoint: /sse
      sse-message-endpoint: /mcp/message
      request-timeout: 60000
      max-connections: 100
      capabilities:
        tool: true
        resource: true
        prompt: true
        completion: true

extraction:
  batch-size: 50
  cache-enabled: true
  ai-timeout: 30s
```

## 6. 核心服务实现

### 6.1 数据库服务
```java
@Service
@Transactional
public class DatabaseService {
    
    @Autowired
    private CelebrityRepository celebrityRepo;
    
    @Autowired
    private WorkRepository workRepo;
    
    @Autowired
    private EventRepository eventRepo;
    
    public void batchSave(List<Celebrity> celebrities, 
                         List<Work> works, 
                         List<Event> events) {
        
        // 批量保存，提升性能
        if (!celebrities.isEmpty()) {
            celebrityRepo.saveAll(celebrities);
        }
        
        if (!works.isEmpty()) {
            workRepo.saveAll(works);
        }
        
        if (!events.isEmpty()) {
            eventRepo.saveAll(events);
        }
    }
}
```

### 6.2 实体映射器
```java
@Component
public class EntityMapper {
    
    public Celebrity toCelebrity(PersonEntity person) {
        Celebrity celebrity = new Celebrity();
        celebrity.setCelebrityId(generateId());
        celebrity.setName(person.getName());
        celebrity.setNationality(person.getNationality());
        celebrity.setBirthdate(person.getBirthdate());
        celebrity.setGender(person.getGender());
        celebrity.setProfession(person.getProfession());
        celebrity.setSpouse(person.getSpouse());
        celebrity.setCompany(person.getCompany());
        celebrity.setPosition(person.getPosition());
        celebrity.setEducation(person.getEducation());
        return celebrity;
    }
    
    public Work toWork(WorkEntity workEntity) {
        Work work = new Work();
        work.setWorkId(generateId());
        work.setTitle(workEntity.getTitle());
        work.setWorkType(workEntity.getWorkType());
        work.setReleaseDate(workEntity.getReleaseDate());
        work.setRole(workEntity.getRole());
        work.setPlatform(workEntity.getPlatform());
        work.setAwards(workEntity.getAwards());
        return work;
    }
    
    public Event toEvent(EventEntity eventEntity) {
        Event event = new Event();
        event.setEventId(generateId());
        event.setEventName(eventEntity.getEventName());
        event.setEventType(EventType.valueOf(eventEntity.getEventType()));
        event.setTime(eventEntity.getTime());
        return event;
    }
}
```

## 7. 部署架构

### 7.1 单体应用部署
```
┌─────────────────────────────────────────┐
│          Extract Service                │
│  ┌─────────────┐  ┌─────────────────┐   │
│  │     MCP     │  │   Data Processor │   │
│  │   Service   │  │   + AI Provider  │   │
│  └─────────────┘  └─────────────────┘   │
└─────────────────────────────────────────┘
           │                    │
           ▼                    ▼
┌─────────────────┐    ┌─────────────────┐
│   Redis Cache   │    │  MySQL Database │
│ localhost:   │    │ localhost:   │
│     6379        │    │     3306        │
└─────────────────┘    └─────────────────┘
```

### 7.2 关键优势
- **部署简单**: 单一JAR包
- **性能高效**: 本地调用，无网络开销
- **数据一致**: 事务保证
- **缓存加速**: Redis提升响应速度

## 8. 性能优化

### 8.1 数据库优化
```java
@Repository
public interface CelebrityRepository extends JpaRepository<Celebrity, Long> {
    
    // 批量插入优化
    @Modifying
    @Query(value = "INSERT INTO celebrity (celebrity_id, name, nationality, gender) VALUES (?1, ?2, ?3, ?4)", nativeQuery = true)
    void batchInsert(String celebrityId, String name, String nationality, String gender);
    
    // 索引查询优化
    @Query("SELECT c FROM Celebrity c WHERE c.name = ?1")
    List<Celebrity> findByNameOptimized(String name);
}
```

### 8.2 缓存优化
```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(60))  // 1小时过期
            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));
            
        return RedisCacheManager.builder(factory)
            .cacheDefaults(config)
            .build();
    }
}
```

## 9. 监控运维

### 9.1 健康检查
```java
@Component
public class HealthIndicator implements org.springframework.boot.actuate.health.HealthIndicator {
    
    @Override
    public Health health() {
        // 检查数据库连接
        if (!isDatabaseHealthy()) {
            return Health.down().withDetail("database", "连接失败").build();
        }
        
        // 检查Redis连接
        if (!isRedisHealthy()) {
            return Health.down().withDetail("redis", "连接失败").build();
        }
        
        return Health.up().build();
    }
}
```

### 9.2 日志配置
```yaml
logging:
  level:
    com.datacenter.extract: INFO
    org.springframework.cache: DEBUG
  pattern:
    console: "%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
  file:
    name: logs/extract-service.log
```

## 10. 核心流程示例

### 10.1 完整处理流程
```java
@Service
public class ExtractionWorkflow {
    
    public String processExtraction(String text) {
        try {
            // 1. 检查缓存
            String cacheKey = generateCacheKey(text);
            String cached = cacheService.get(cacheKey);
            if (cached != null) {
                return cached;
            }
            
            // 2. AI提取
            ExtractionResult result = aiProvider.extract(text);
            
            // 3. 数据验证
            validateResult(result);
            
            // 4. 数据映射
            List<Celebrity> celebrities = entityMapper.toCelebrities(result.getPersons());
            List<Work> works = entityMapper.toWorks(result.getWorks());
            List<Event> events = entityMapper.toEvents(result.getEvents());
            
            // 5. 批量入库
            databaseService.batchSave(celebrities, works, events);
            
            // 6. 保存关系
            relationService.saveRelations(result.getRelations());
            
            // 7. 格式化返回
            String response = formatResponse(result);
            
            // 8. 更新缓存
            cacheService.put(cacheKey, response);
            
            return response;
            
        } catch (Exception e) {
            log.error("提取处理失败: {}", e.getMessage());
            return createErrorResponse(e);
        }
    }
}
```

---

## 总结

本架构设计严格遵循**"简洁至上"**原则：

- **保持MCP协议**: 不改变现有接口规范
- **直接数据入库**: 提取结果实时存储到MySQL
- **Redis加速**: 缓存热点数据，提升响应速度
- **批量处理**: 优化数据库操作性能
- **事务保证**: 确保数据一致性

整个系统采用**"一条龙"**服务模式：文本进来 → AI处理 → 数据入库 → 结果返回，流程清晰，逻辑简单，易于维护和扩展。
 