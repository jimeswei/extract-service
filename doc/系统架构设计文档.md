# 智能文本提取服务 - 系统架构设计文档

## 1. 架构设计哲学

### 1.1 设计原则
> "简单是终极的复杂" - 达芬奇

**核心理念**: 用最简单的架构解决最复杂的业务问题

- **单一职责**: 每个组件只做一件事，并做到极致
- **分层解耦**: 业务逻辑与技术实现完全分离
- **响应式设计**: 基于事件驱动的异步处理模式
- **巧妙抽象**: 将复杂的AI处理过程抽象为简单的工具调用

### 1.2 架构巧思
```
复杂业务 → 简单抽象 → 标准接口 → 高效实现
```

## 2. 巧妙的分层架构设计

### 2.1 四层架构模式
```
┌─────────────────────────────────────────────────┐
│           MCP Tool Interface Layer              │  ← 标准化工具接口
├─────────────────────────────────────────────────┤
│         Business Orchestration Layer           │  ← 业务编排逻辑
├─────────────────────────────────────────────────┤
│           Core Processing Layer                 │  ← 核心处理引擎
├─────────────────────────────────────────────────┤
│         Infrastructure Layer                    │  ← 基础设施支撑
└─────────────────────────────────────────────────┘
```

### 2.2 架构亮点设计

#### 2.2.1 智能工具抽象层
通过MCP标准将复杂的文本处理流程抽象为简单的工具调用：

```java
// 巧妙设计：一个注解解决复杂的工具注册
@Tool(name = "extract_knowledge", 
      description = "智能提取文本中的知识三元组，支持中英文混合文本。参数格式：1.text: 待处理文本内容，2.extractType: 提取类型(triples/entities/relations)，3.language: 语言类型(auto/zh/en)")
public ExtractionResult extractKnowledge(String text, String extractType, String language) {
    return businessOrchestrator.orchestrate(
        ExtractionRequest.builder()
            .text(text)
            .type(ExtractionType.valueOf(extractType.toUpperCase()))
            .language(Language.parse(language))
            .build()
    );
}
```

#### 2.2.2 业务编排层巧思
使用责任链模式 + 策略模式，将复杂的处理流程简化：

```java
@Component
public class BusinessOrchestrator {
    
    // 巧妙设计：自动装配处理链，无需手动配置
    private final List<ProcessingStep> processingChain;
    
    public ExtractionResult orchestrate(ExtractionRequest request) {
        return processingChain.stream()
            .filter(step -> step.canHandle(request))
            .findFirst()
            .map(step -> step.process(request))
            .orElse(ExtractionResult.empty());
    }
}
```

## 3. MCP SSE标准实现架构

### 3.1 MCP配置设计
```java
@Configuration
public class MCPConfig {
    
    @Bean
    public ToolCallbackProvider extractionTools(TextExtractionService textExtractionService) {
        return MethodToolCallbackProvider.builder()
            .toolObjects(textExtractionService)
            .build();
    }
    
    // 巧妙设计：自动发现所有@Tool方法，无需手动注册
    @Bean
    public SSEEndpointConfig sseConfig() {
        return SSEEndpointConfig.builder()
            .endpoint("/sse")
            .messageEndpoint("/mcp/message")
            .heartbeatInterval(30)
            .maxConnections(1000)
            .build();
    }
}
```

### 3.2 核心服务实现
```java
@Service
@Slf4j
public class TextExtractionService {
    
    private final IntelligentCache cache;
    private final AIProviderChain aiChain;
    private final ResultProcessor resultProcessor;
    
    @Tool(name = "extract_triples", 
          description = "从文本中提取知识三元组，自动识别实体和关系。参数格式：1.text: 文本内容，2.extractType: 提取类型(默认triples)，3.options: 额外选项(可选)")
    public String extractTriples(String text, String extractType, String options) {
        
        // 巧妙设计：智能缓存键生成，考虑所有影响因子
        String cacheKey = CacheKeyGenerator.generate(text, extractType, options);
        
        return cache.computeIfAbsent(cacheKey, key -> {
            try {
                // 责任链处理
                ProcessingContext context = ProcessingContext.builder()
                    .text(text)
                    .extractType(extractType)
                    .options(parseOptions(options))
                    .build();
                
                ExtractionResult result = aiChain.process(context);
                return resultProcessor.format(result);
                
            } catch (Exception e) {
                log.error("提取失败: {}", e.getMessage());
                return ErrorResponse.create(e).toJson();
            }
        });
    }
    
    @Tool(name = "batch_extract", 
          description = "批量提取多个文本的知识三元组，自动并行处理提升效率。参数格式：1.texts: 文本数组(JSON格式)，2.extractType: 提取类型，3.batchSize: 批次大小(可选)")
    public String batchExtract(String texts, String extractType, String batchSize) {
        
        // 巧妙设计：自适应批处理大小
        int optimalBatchSize = BatchSizeOptimizer.calculate(texts, batchSize);
        
        List<String> textList = JsonUtils.parseArray(texts, String.class);
        
        return textList.stream()
            .collect(Collectors.groupingBy(
                text -> text.hashCode() % optimalBatchSize  // 智能分组
            ))
            .values().parallelStream()  // 并行处理
            .flatMap(batch -> processBatch(batch, extractType).stream())
            .collect(Collectors.toList())
            .toString();
    }
    
    @Tool(name = "health_check", 
          description = "检查服务健康状态，包括AI API可用性和系统资源状态。参数格式：无需参数")
    public String healthCheck() {
        
        HealthStatus status = HealthChecker.builder()
            .checkAIProvider(aiChain::isHealthy)
            .checkCache(cache::isHealthy)
            .checkMemory(() -> MemoryUtils.getUsagePercentage() < 80)
            .build()
            .check();
            
        return HealthResponse.create(status).toJson();
    }
}
```

## 4. 智能处理引擎设计

### 4.1 极简大模型调用设计

#### 4.1.1 巧妙的AI调用抽象
```java
@Component
@Slf4j
public class AIModelCaller {
    
    private final WebClient deepseekClient;
    private final String apiKey;
    
    public AIModelCaller(WebClient.Builder builder, 
                        @Value("${extraction.ai.providers.deepseek.api-key}") String apiKey) {
        this.apiKey = apiKey;
        this.deepseekClient = builder
            .baseUrl("https://api.deepseek.com")
            .defaultHeader("Authorization", "Bearer " + apiKey)
            .build();
    }
    
    // 巧妙设计：一个方法解决所有AI调用
    public String callAI(String text, String extractType) {
        try {
            return deepseekClient.post()
                .uri("/v1/chat/completions")
                .bodyValue(buildRequest(text, extractType))
                .retrieve()
                .bodyToMono(String.class)
                .timeout(Duration.ofSeconds(30))
                .retryWhen(Retry.fixedDelay(2, Duration.ofSeconds(1)))
                .map(this::extractContent)
                .onErrorReturn(createErrorResponse())
                .block();
        } catch (Exception e) {
            log.error("AI调用失败: {}", e.getMessage());
            return createErrorResponse();
        }
    }
    
    // 巧妙设计：智能Prompt构建
    private Map<String, Object> buildRequest(String text, String extractType) {
        String prompt = String.format("""
            从文本中提取知识三元组，JSON格式返回：
            {"triples":[{"subject":"主体","predicate":"关系","object":"客体","confidence":0.95}]}
            
            文本：%s
            """, text.length() > 2000 ? text.substring(0, 2000) + "..." : text);
            
        return Map.of(
            "model", "deepseek-chat",
            "messages", List.of(Map.of("role", "user", "content", prompt)),
            "temperature", 0.1,
            "max_tokens", 1500
        );
    }
    
    // 巧妙设计：响应内容智能提取
    private String extractContent(String response) {
        try {
            JsonNode root = new ObjectMapper().readTree(response);
            String content = root.path("choices").get(0).path("message").path("content").asText();
            
            // 智能清理：只保留JSON部分
            int start = content.indexOf("{");
            int end = content.lastIndexOf("}") + 1;
            return start >= 0 && end > start ? content.substring(start, end) : content;
            
        } catch (Exception e) {
            return createErrorResponse();
        }
    }
    
    private String createErrorResponse() {
        return """
            {"triples":[],"error":"AI处理失败","success":false}
            """;
    }
}
```

#### 4.1.2 智能Provider责任链
```java
@Component
public class SmartAIProvider {
    
    private final AIModelCaller aiCaller;
    private final Cache<String, String> cache;
    
    public SmartAIProvider(AIModelCaller aiCaller) {
        this.aiCaller = aiCaller;
        this.cache = Caffeine.newBuilder()
            .maximumSize(500)
            .expireAfterWrite(1, TimeUnit.HOURS)
            .build();
    }
    
    // 巧妙设计：缓存+AI调用+兜底的三层保障
    public String process(String text, String extractType) {
        String cacheKey = generateKey(text, extractType);
        
        return cache.get(cacheKey, key -> {
            // 第一选择：AI调用
            String aiResult = aiCaller.callAI(text, extractType);
            
            // 智能判断：如果AI失败，使用规则兜底
            if (isValidResponse(aiResult)) {
                return aiResult;
            } else {
                return createFallbackResponse(text);
            }
        });
    }
    
    // 巧妙设计：简单规则兜底
    private String createFallbackResponse(String text) {
        // 使用简单规则提取实体作为兜底
        List<String> entities = extractSimpleEntities(text);
        
        List<Map<String, Object>> triples = new ArrayList<>();
        for (int i = 0; i < entities.size() - 1; i++) {
            triples.add(Map.of(
                "subject", entities.get(i),
                "predicate", "相关",
                "object", entities.get(i + 1),
                "confidence", 0.6
            ));
        }
        
        try {
            return new ObjectMapper().writeValueAsString(Map.of(
                "triples", triples,
                "success", true,
                "fallback", true
            ));
        } catch (Exception e) {
            return """
                {"triples":[],"error":"兜底处理失败","success":false}
                """;
        }
    }
    
    // 巧妙设计：正则简单实体提取
    private List<String> extractSimpleEntities(String text) {
        Pattern pattern = Pattern.compile("[\u4e00-\u9fa5]{2,8}(?:公司|企业|机构|大学|学院|医院|银行)");
        return pattern.matcher(text)
            .results()
            .map(MatchResult::group)
            .distinct()
            .limit(5)
            .collect(Collectors.toList());
    }
    
    private boolean isValidResponse(String response) {
        return response.contains("triples") && 
               response.contains("success") && 
               !response.contains("error");
    }
    
    private String generateKey(String text, String extractType) {
        return Math.abs((text + extractType).hashCode()) + "";
    }
}
```

#### 4.1.3 超简洁的服务集成
```java
// 巧妙设计：在原有MCP服务中直接集成
@Tool(name = "extract_triples", 
      description = "从文本中提取知识三元组，自动AI处理+缓存+兜底。参数格式：1.text: 文本内容，2.extractType: 提取类型(默认triples)，3.options: 额外选项(可选)")
public String extractTriples(String text, String extractType, String options) {
    
    // 巧妙设计：三行代码完成所有逻辑
    String cacheKey = CacheKeyGenerator.generate(text, extractType, options);
    
    return cache.computeIfAbsent(cacheKey, key -> 
        smartAIProvider.process(text, extractType)  // AI调用+兜底一体化
    );
}
```

### 4.2 智能缓存设计
```java
@Component
public class IntelligentCache {
    
    private final Cache<String, String> l1Cache;  // 内存缓存
    private final Cache<String, String> l2Cache;  // 持久化缓存
    
    // 巧妙设计：二级缓存自动降级
    public String computeIfAbsent(String key, Function<String, String> computer) {
        
        // L1缓存查找
        String result = l1Cache.getIfPresent(key);
        if (result != null) {
            MetricsCollector.recordCacheHit("L1");
            return result;
        }
        
        // L2缓存查找  
        result = l2Cache.getIfPresent(key);
        if (result != null) {
            MetricsCollector.recordCacheHit("L2");
            l1Cache.put(key, result);  // 回填L1
            return result;
        }
        
        // 计算新结果
        result = computer.apply(key);
        
        // 智能缓存策略
        if (shouldCacheL1(result)) {
            l1Cache.put(key, result);
        }
        if (shouldCacheL2(result)) {
            l2Cache.put(key, result);
        }
        
        return result;
    }
}
```

## 5. 配置文件设计

### 5.1 application.yaml巧妙配置
```yaml
server:
  port: 2701
  
spring:
  application:
    name: extract-service
    
# MCP SSE 核心配置
ai:
  mcp:
    server:
      name: intelligent-extraction-service
      type: ASYNC
      enabled: true
      sse-endpoint: /sse
      sse-message-endpoint: /mcp/message
      
# 智能配置：自适应参数
extraction:
  ai:
    providers:
      deepseek:
        api-key: sk-3b61aec308d543be81a499e1c82cf2d4
        url: https://api.deepseek.com/v1/chat/completions
        timeout: 30s
        retry-count: 3
        fallback-enabled: true
      local:
        enabled: true
        confidence-threshold: 0.7
        
  cache:
    l1:
      type: caffeine
      max-size: 1000
      expire-after-write: 1h
    l2:
      type: file
      max-size: 10000
      expire-after-write: 24h
      
  processing:
    batch-size: 10
    parallel-threads: 4
    timeout: 60s
    
# 智能监控配置
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,info
  metrics:
    export:
      prometheus:
        enabled: true
    distribution:
      percentiles:
        http.server.requests: 0.5,0.95,0.99
```

## 6. 巧妙的错误处理策略

### 6.1 分层错误处理
```java
@ControllerAdvice
public class GlobalExceptionHandler {
    
    // 巧妙设计：根据异常类型自动选择处理策略
    @ExceptionHandler(AIProviderException.class)
    public ResponseEntity<ErrorResponse> handleAIError(AIProviderException e) {
        
        // 智能降级：AI失败时自动使用本地处理
        if (e.isRetryable()) {
            LocalProcessingTrigger.trigger(e.getContext());
        }
        
        return ResponseEntity.status(503)
            .body(ErrorResponse.builder()
                .code("AI_PROVIDER_ERROR")
                .message("AI服务暂时不可用，已启用备用处理")
                .suggestion("请稍后重试")
                .build());
    }
    
    @ExceptionHandler(CacheException.class)
    public ResponseEntity<ErrorResponse> handleCacheError(CacheException e) {
        
        // 巧妙设计：缓存失败时透明降级
        CacheEvictionTrigger.evictCorrupted();
        
        return ResponseEntity.ok(
            ErrorResponse.builder()
                .code("CACHE_MISS")
                .message("缓存未命中，正在重新计算")
                .build()
        );
    }
}
```

## 7. 性能优化架构

### 7.1 智能资源管理
```java
@Component
public class ResourceOptimizer {
    
    @Scheduled(fixedRate = 60000)  // 每分钟执行
    public void optimizeResources() {
        
        // 巧妙设计：自适应资源调整
        double memoryUsage = MemoryUtils.getUsagePercentage();
        double cpuUsage = CpuUtils.getUsagePercentage();
        
        if (memoryUsage > 80) {
            // 智能缓存清理
            cacheManager.evictLowPriorityEntries();
            garbageCollector.suggest();
        }
        
        if (cpuUsage > 90) {
            // 自动限流
            rateLimiter.enableStrictMode();
            batchProcessor.reduceParallelism();
        }
        
        // 预测性扩缩容
        if (requestPredictor.predictHighLoad()) {
            resourceManager.preWarmInstances();
        }
    }
}
```

### 7.2 智能负载均衡
```java
@Component  
public class IntelligentLoadBalancer {
    
    // 巧妙设计：基于实时性能的智能路由
    public AIProvider selectProvider(ProcessingContext context) {
        
        return providers.stream()
            .filter(provider -> provider.isHealthy())
            .min(Comparator.comparing(provider -> 
                calculateScore(provider, context)
            ))
            .orElse(fallbackProvider);
    }
    
    private double calculateScore(AIProvider provider, ProcessingContext context) {
        double latencyScore = provider.getAverageLatency() * 0.4;
        double loadScore = provider.getCurrentLoad() * 0.3;
        double accuracyScore = (1.0 - provider.getAccuracy()) * 0.2;
        double costScore = provider.getCostPerRequest() * 0.1;
        
        return latencyScore + loadScore + accuracyScore + costScore;
    }
}
```

## 8. 部署架构设计

### 8.1 容器化配置
```yaml
# docker-compose.yml
version: '3.8'
services:
  extract-service:
    build: .
         ports:
       - "2701:2701"
    environment:
      - DEEPSEEK_API_KEY=sk-3b61aec308d543be81a499e1c82cf2d4
      - SPRING_PROFILES_ACTIVE=prod
    volumes:
      - cache-volume:/app/cache
    healthcheck:
             test: ["CMD", "curl", "-f", "http://localhost:2701/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
        reservations:
          memory: 256M
          cpus: '0.25'

volumes:
  cache-volume:
```

## 9. 监控与可观测性

### 9.1 智能监控策略
```java
@Component
public class IntelligentMonitor {
    
    // 巧妙设计：自动异常检测
    @EventListener
    public void handleMetric(MetricEvent event) {
        
        if (anomalyDetector.isAnomalous(event)) {
            
            // 智能告警降噪
            if (alertThrottler.shouldAlert(event)) {
                alertManager.sendIntelligentAlert(
                    AlertBuilder.create()
                        .severity(calculateSeverity(event))
                        .context(gatherContext(event))
                        .suggestions(generateSuggestions(event))
                        .build()
                );
            }
            
            // 自动修复尝试
            autoHealer.attemptFix(event);
        }
    }
}
```

## 10. 架构演进路线

### 10.1 技术债务管理
```java
@Component
public class ArchitectureEvolution {
    
    @Scheduled(cron = "0 0 0 * * SUN")  // 每周日评估
    public void assessArchitecture() {
        
        ArchitectureHealth health = ArchitectureAnalyzer.builder()
            .checkCodeQuality()
            .checkPerformance()
            .checkScalability()
            .checkMaintainability()
            .build()
            .analyze();
            
        if (health.needsRefactoring()) {
            RefactoringPlan plan = planGenerator.generatePlan(health);
            evolutionTracker.schedulePlan(plan);
        }
    }
}
```

## 总结

### 核心架构优势

1. **极简设计**: 用最少的组件实现最复杂的功能
2. **智能抽象**: MCP工具接口隐藏了底层复杂性
3. **自适应能力**: 系统能根据负载自动调优
4. **巧妙容错**: 多层降级策略保证服务稳定
5. **可观测性**: 全方位监控与智能告警

### 设计哲学体现

**"化繁为简"**: 将复杂的AI文本处理抽象为简单的工具调用
**"智能决策"**: 系统能根据实际情况自动做出最优选择  
**"优雅降级"**: 在各种异常情况下都能提供基础服务
**"持续演进"**: 架构支持平滑的功能扩展和技术升级

这个架构设计体现了"大道至简"的哲学，用最简洁的代码实现了最复杂的业务需求，是现代软件架构设计的典范。
 